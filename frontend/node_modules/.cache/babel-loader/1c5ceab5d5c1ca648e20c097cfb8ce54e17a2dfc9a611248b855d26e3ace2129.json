{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n */\n'use strict';\n\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nvar _excluded = [\"stickySectionHeadersEnabled\"];\nimport Platform from '../../../exports/Platform';\nimport * as React from 'react';\nimport VirtualizedSectionList from '../VirtualizedSectionList';\n\n/**\r\n * A performant interface for rendering sectioned lists, supporting the most handy features:\r\n *\r\n *  - Fully cross-platform.\r\n *  - Configurable viewability callbacks.\r\n *  - List header support.\r\n *  - List footer support.\r\n *  - Item separator support.\r\n *  - Section header support.\r\n *  - Section separator support.\r\n *  - Heterogeneous data and item rendering support.\r\n *  - Pull to Refresh.\r\n *  - Scroll loading.\r\n *\r\n * If you don't need section support and want a simpler interface, use\r\n * [`<FlatList>`](https://reactnative.dev/docs/flatlist).\r\n *\r\n * Simple Examples:\r\n *\r\n *     <SectionList\r\n *       renderItem={({item}) => <ListItem title={item} />}\r\n *       renderSectionHeader={({section}) => <Header title={section.title} />}\r\n *       sections={[ // homogeneous rendering between sections\r\n *         {data: [...], title: ...},\r\n *         {data: [...], title: ...},\r\n *         {data: [...], title: ...},\r\n *       ]}\r\n *     />\r\n *\r\n *     <SectionList\r\n *       sections={[ // heterogeneous rendering between sections\r\n *         {data: [...], renderItem: ...},\r\n *         {data: [...], renderItem: ...},\r\n *         {data: [...], renderItem: ...},\r\n *       ]}\r\n *     />\r\n *\r\n * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist),\r\n * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed\r\n * here, along with the following caveats:\r\n *\r\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\r\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\r\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\r\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\r\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\r\n *   changes. This includes the `data` prop and parent component state.\r\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\r\n *   offscreen. This means it's possible to scroll faster than the fill rate and momentarily see\r\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\r\n *   and we are working on improving it behind the scenes.\r\n * - By default, the list looks for a `key` prop on each item and uses that for the React key.\r\n *   Alternatively, you can provide a custom `keyExtractor` prop.\r\n *\r\n */\nexport default class SectionList extends React.PureComponent {\n  constructor() {\n    super(...arguments);\n    this._captureRef = ref => {\n      this._wrapperListRef = ref;\n    };\n  }\n\n  /**\r\n   * Scrolls to the item at the specified `sectionIndex` and `itemIndex` (within the section)\r\n   * positioned in the viewable area such that `viewPosition` 0 places it at the top (and may be\r\n   * covered by a sticky header), 1 at the bottom, and 0.5 centered in the middle. `viewOffset` is a\r\n   * fixed number of pixels to offset the final target position, e.g. to compensate for sticky\r\n   * headers.\r\n   *\r\n   * Note: cannot scroll to locations outside the render window without specifying the\r\n   * `getItemLayout` prop.\r\n   */\n  scrollToLocation(params) {\n    if (this._wrapperListRef != null) {\n      this._wrapperListRef.scrollToLocation(params);\n    }\n  }\n  /**\r\n   * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.\r\n   * if `waitForInteractions` is true and the user has not scrolled. This is typically called by\r\n   * taps on items or by navigation actions.\r\n   */\n\n  recordInteraction() {\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    listRef && listRef.recordInteraction();\n  }\n  /**\r\n   * Displays the scroll indicators momentarily.\r\n   *\r\n   * @platform ios\r\n   */\n\n  flashScrollIndicators() {\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    listRef && listRef.flashScrollIndicators();\n  }\n  /**\r\n   * Provides a handle to the underlying scroll responder.\r\n   */\n\n  getScrollResponder() {\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    if (listRef) {\n      return listRef.getScrollResponder();\n    }\n  }\n  getScrollableNode() {\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    if (listRef) {\n      return listRef.getScrollableNode();\n    }\n  }\n  setNativeProps(props) {\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    if (listRef) {\n      listRef.setNativeProps(props);\n    }\n  }\n  render() {\n    var _this$props = this.props,\n      _stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,\n      restProps = _objectWithoutPropertiesLoose(_this$props, _excluded);\n    var stickySectionHeadersEnabled = _stickySectionHeadersEnabled !== null && _stickySectionHeadersEnabled !== void 0 ? _stickySectionHeadersEnabled : Platform.OS === 'ios';\n    return /*#__PURE__*/React.createElement(VirtualizedSectionList, _extends({}, restProps, {\n      stickySectionHeadersEnabled: stickySectionHeadersEnabled,\n      ref: this._captureRef,\n      getItemCount: items => items.length,\n      getItem: (items, index) => items[index]\n    }));\n  }\n}","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","_excluded","Platform","React","VirtualizedSectionList","SectionList","PureComponent","constructor","arguments","_captureRef","ref","_wrapperListRef","scrollToLocation","params","recordInteraction","listRef","getListRef","flashScrollIndicators","getScrollResponder","getScrollableNode","setNativeProps","props","render","_this$props","_stickySectionHeadersEnabled","stickySectionHeadersEnabled","restProps","OS","createElement","getItemCount","items","length","getItem","index"],"sources":["C:/Users/Luc/Documents/ecole/2022_2023/ASI2/Atelier2/atelier2/frontend/node_modules/react-native-web/dist/vendor/react-native/SectionList/index.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n */\r\n'use strict';\r\n\r\nimport _extends from \"@babel/runtime/helpers/extends\";\r\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\r\nvar _excluded = [\"stickySectionHeadersEnabled\"];\r\nimport Platform from '../../../exports/Platform';\r\nimport * as React from 'react';\r\nimport VirtualizedSectionList from '../VirtualizedSectionList';\r\n\r\n/**\r\n * A performant interface for rendering sectioned lists, supporting the most handy features:\r\n *\r\n *  - Fully cross-platform.\r\n *  - Configurable viewability callbacks.\r\n *  - List header support.\r\n *  - List footer support.\r\n *  - Item separator support.\r\n *  - Section header support.\r\n *  - Section separator support.\r\n *  - Heterogeneous data and item rendering support.\r\n *  - Pull to Refresh.\r\n *  - Scroll loading.\r\n *\r\n * If you don't need section support and want a simpler interface, use\r\n * [`<FlatList>`](https://reactnative.dev/docs/flatlist).\r\n *\r\n * Simple Examples:\r\n *\r\n *     <SectionList\r\n *       renderItem={({item}) => <ListItem title={item} />}\r\n *       renderSectionHeader={({section}) => <Header title={section.title} />}\r\n *       sections={[ // homogeneous rendering between sections\r\n *         {data: [...], title: ...},\r\n *         {data: [...], title: ...},\r\n *         {data: [...], title: ...},\r\n *       ]}\r\n *     />\r\n *\r\n *     <SectionList\r\n *       sections={[ // heterogeneous rendering between sections\r\n *         {data: [...], renderItem: ...},\r\n *         {data: [...], renderItem: ...},\r\n *         {data: [...], renderItem: ...},\r\n *       ]}\r\n *     />\r\n *\r\n * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist),\r\n * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed\r\n * here, along with the following caveats:\r\n *\r\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\r\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\r\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\r\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\r\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\r\n *   changes. This includes the `data` prop and parent component state.\r\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\r\n *   offscreen. This means it's possible to scroll faster than the fill rate and momentarily see\r\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\r\n *   and we are working on improving it behind the scenes.\r\n * - By default, the list looks for a `key` prop on each item and uses that for the React key.\r\n *   Alternatively, you can provide a custom `keyExtractor` prop.\r\n *\r\n */\r\nexport default class SectionList extends React.PureComponent {\r\n  constructor() {\r\n    super(...arguments);\r\n\r\n    this._captureRef = ref => {\r\n      this._wrapperListRef = ref;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Scrolls to the item at the specified `sectionIndex` and `itemIndex` (within the section)\r\n   * positioned in the viewable area such that `viewPosition` 0 places it at the top (and may be\r\n   * covered by a sticky header), 1 at the bottom, and 0.5 centered in the middle. `viewOffset` is a\r\n   * fixed number of pixels to offset the final target position, e.g. to compensate for sticky\r\n   * headers.\r\n   *\r\n   * Note: cannot scroll to locations outside the render window without specifying the\r\n   * `getItemLayout` prop.\r\n   */\r\n  scrollToLocation(params) {\r\n    if (this._wrapperListRef != null) {\r\n      this._wrapperListRef.scrollToLocation(params);\r\n    }\r\n  }\r\n  /**\r\n   * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.\r\n   * if `waitForInteractions` is true and the user has not scrolled. This is typically called by\r\n   * taps on items or by navigation actions.\r\n   */\r\n\r\n\r\n  recordInteraction() {\r\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\r\n\r\n    listRef && listRef.recordInteraction();\r\n  }\r\n  /**\r\n   * Displays the scroll indicators momentarily.\r\n   *\r\n   * @platform ios\r\n   */\r\n\r\n\r\n  flashScrollIndicators() {\r\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\r\n\r\n    listRef && listRef.flashScrollIndicators();\r\n  }\r\n  /**\r\n   * Provides a handle to the underlying scroll responder.\r\n   */\r\n\r\n\r\n  getScrollResponder() {\r\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\r\n\r\n    if (listRef) {\r\n      return listRef.getScrollResponder();\r\n    }\r\n  }\r\n\r\n  getScrollableNode() {\r\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\r\n\r\n    if (listRef) {\r\n      return listRef.getScrollableNode();\r\n    }\r\n  }\r\n\r\n  setNativeProps(props) {\r\n    var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\r\n\r\n    if (listRef) {\r\n      listRef.setNativeProps(props);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    var _this$props = this.props,\r\n        _stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,\r\n        restProps = _objectWithoutPropertiesLoose(_this$props, _excluded);\r\n\r\n    var stickySectionHeadersEnabled = _stickySectionHeadersEnabled !== null && _stickySectionHeadersEnabled !== void 0 ? _stickySectionHeadersEnabled : Platform.OS === 'ios';\r\n    return /*#__PURE__*/React.createElement(VirtualizedSectionList, _extends({}, restProps, {\r\n      stickySectionHeadersEnabled: stickySectionHeadersEnabled,\r\n      ref: this._captureRef,\r\n      getItemCount: items => items.length,\r\n      getItem: (items, index) => items[index]\r\n    }));\r\n  }\r\n\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}