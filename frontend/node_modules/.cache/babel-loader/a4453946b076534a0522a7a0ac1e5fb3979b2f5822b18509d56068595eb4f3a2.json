{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\nimport { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\n\n/**\r\n * Tracks the position and time of each active touch by `touch.identifier`. We\r\n * should typically only see IDs in the range of 1-20 because IDs get recycled\r\n * when touches end and start again.\r\n */\nvar __DEV__ = process.env.NODE_ENV !== 'production';\nvar MAX_TOUCH_BANK = 20;\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return touch.timeStamp || touch.timestamp;\n}\n/**\r\n * TODO: Instead of making gestures recompute filtered velocity, we could\r\n * include a built in velocity computation that can be reused globally.\r\n */\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n  return identifier;\n}\nfunction recordTouchStart(touch, touchHistory) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchHistory.touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\nfunction recordTouchMove(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\nfunction recordTouchEnd(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\nfunction printTouchBank(touchHistory) {\n  var touchBank = touchHistory.touchBank;\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n  return printed;\n}\nexport class ResponderTouchHistoryStore {\n  constructor() {\n    this._touchHistory = {\n      touchBank: [],\n      //Array<TouchRecord>\n      numberActiveTouches: 0,\n      // If there is only one active touch, we remember its location. This prevents\n      // us having to loop through all of the touches all the time in the most\n      // common case.\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n  }\n  recordTouchTrack(topLevelType, nativeEvent) {\n    var touchHistory = this._touchHistory;\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        var touchBank = touchHistory.touchBank;\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  }\n  get touchHistory() {\n    return this._touchHistory;\n  }\n}","map":{"version":3,"names":["isStartish","isMoveish","isEndish","__DEV__","process","env","NODE_ENV","MAX_TOUCH_BANK","timestampForTouch","touch","timeStamp","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","console","error","recordTouchStart","touchHistory","touchBank","mostRecentTimeStamp","recordTouchMove","warn","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","length","ResponderTouchHistoryStore","constructor","_touchHistory","numberActiveTouches","indexOfSingleActiveTouch","recordTouchTrack","topLevelType","nativeEvent","changedTouches","forEach","touches","i","touchTrackToCheck","activeRecord"],"sources":["C:/Users/Luc/Documents/ecole/2022_2023/ASI2/Atelier2/atelier2/frontend/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderTouchHistoryStore.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\r\nimport { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\r\n\r\n/**\r\n * Tracks the position and time of each active touch by `touch.identifier`. We\r\n * should typically only see IDs in the range of 1-20 because IDs get recycled\r\n * when touches end and start again.\r\n */\r\nvar __DEV__ = process.env.NODE_ENV !== 'production';\r\n\r\nvar MAX_TOUCH_BANK = 20;\r\n\r\nfunction timestampForTouch(touch) {\r\n  // The legacy internal implementation provides \"timeStamp\", which has been\r\n  // renamed to \"timestamp\".\r\n  return touch.timeStamp || touch.timestamp;\r\n}\r\n/**\r\n * TODO: Instead of making gestures recompute filtered velocity, we could\r\n * include a built in velocity computation that can be reused globally.\r\n */\r\n\r\n\r\nfunction createTouchRecord(touch) {\r\n  return {\r\n    touchActive: true,\r\n    startPageX: touch.pageX,\r\n    startPageY: touch.pageY,\r\n    startTimeStamp: timestampForTouch(touch),\r\n    currentPageX: touch.pageX,\r\n    currentPageY: touch.pageY,\r\n    currentTimeStamp: timestampForTouch(touch),\r\n    previousPageX: touch.pageX,\r\n    previousPageY: touch.pageY,\r\n    previousTimeStamp: timestampForTouch(touch)\r\n  };\r\n}\r\n\r\nfunction resetTouchRecord(touchRecord, touch) {\r\n  touchRecord.touchActive = true;\r\n  touchRecord.startPageX = touch.pageX;\r\n  touchRecord.startPageY = touch.pageY;\r\n  touchRecord.startTimeStamp = timestampForTouch(touch);\r\n  touchRecord.currentPageX = touch.pageX;\r\n  touchRecord.currentPageY = touch.pageY;\r\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\r\n  touchRecord.previousPageX = touch.pageX;\r\n  touchRecord.previousPageY = touch.pageY;\r\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\r\n}\r\n\r\nfunction getTouchIdentifier(_ref) {\r\n  var identifier = _ref.identifier;\r\n\r\n  if (identifier == null) {\r\n    console.error('Touch object is missing identifier.');\r\n  }\r\n\r\n  if (__DEV__) {\r\n    if (identifier > MAX_TOUCH_BANK) {\r\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\r\n    }\r\n  }\r\n\r\n  return identifier;\r\n}\r\n\r\nfunction recordTouchStart(touch, touchHistory) {\r\n  var identifier = getTouchIdentifier(touch);\r\n  var touchRecord = touchHistory.touchBank[identifier];\r\n\r\n  if (touchRecord) {\r\n    resetTouchRecord(touchRecord, touch);\r\n  } else {\r\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\r\n  }\r\n\r\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\r\n}\r\n\r\nfunction recordTouchMove(touch, touchHistory) {\r\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\r\n\r\n  if (touchRecord) {\r\n    touchRecord.touchActive = true;\r\n    touchRecord.previousPageX = touchRecord.currentPageX;\r\n    touchRecord.previousPageY = touchRecord.currentPageY;\r\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\r\n    touchRecord.currentPageX = touch.pageX;\r\n    touchRecord.currentPageY = touch.pageY;\r\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\r\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\r\n  } else {\r\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\r\n  }\r\n}\r\n\r\nfunction recordTouchEnd(touch, touchHistory) {\r\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\r\n\r\n  if (touchRecord) {\r\n    touchRecord.touchActive = false;\r\n    touchRecord.previousPageX = touchRecord.currentPageX;\r\n    touchRecord.previousPageY = touchRecord.currentPageY;\r\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\r\n    touchRecord.currentPageX = touch.pageX;\r\n    touchRecord.currentPageY = touch.pageY;\r\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\r\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\r\n  } else {\r\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\r\n  }\r\n}\r\n\r\nfunction printTouch(touch) {\r\n  return JSON.stringify({\r\n    identifier: touch.identifier,\r\n    pageX: touch.pageX,\r\n    pageY: touch.pageY,\r\n    timestamp: timestampForTouch(touch)\r\n  });\r\n}\r\n\r\nfunction printTouchBank(touchHistory) {\r\n  var touchBank = touchHistory.touchBank;\r\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\r\n\r\n  if (touchBank.length > MAX_TOUCH_BANK) {\r\n    printed += ' (original size: ' + touchBank.length + ')';\r\n  }\r\n\r\n  return printed;\r\n}\r\n\r\nexport class ResponderTouchHistoryStore {\r\n  constructor() {\r\n    this._touchHistory = {\r\n      touchBank: [],\r\n      //Array<TouchRecord>\r\n      numberActiveTouches: 0,\r\n      // If there is only one active touch, we remember its location. This prevents\r\n      // us having to loop through all of the touches all the time in the most\r\n      // common case.\r\n      indexOfSingleActiveTouch: -1,\r\n      mostRecentTimeStamp: 0\r\n    };\r\n  }\r\n\r\n  recordTouchTrack(topLevelType, nativeEvent) {\r\n    var touchHistory = this._touchHistory;\r\n\r\n    if (isMoveish(topLevelType)) {\r\n      nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));\r\n    } else if (isStartish(topLevelType)) {\r\n      nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));\r\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\r\n\r\n      if (touchHistory.numberActiveTouches === 1) {\r\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\r\n      }\r\n    } else if (isEndish(topLevelType)) {\r\n      nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));\r\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\r\n\r\n      if (touchHistory.numberActiveTouches === 1) {\r\n        var touchBank = touchHistory.touchBank;\r\n\r\n        for (var i = 0; i < touchBank.length; i++) {\r\n          var touchTrackToCheck = touchBank[i];\r\n\r\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\r\n            touchHistory.indexOfSingleActiveTouch = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (__DEV__) {\r\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\r\n\r\n          if (!(activeRecord != null && activeRecord.touchActive)) {\r\n            console.error('Cannot find single active touch.');\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  get touchHistory() {\r\n    return this._touchHistory;\r\n  }\r\n\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}