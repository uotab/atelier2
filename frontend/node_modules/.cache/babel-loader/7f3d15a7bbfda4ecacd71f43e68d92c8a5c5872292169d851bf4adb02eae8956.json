{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n */\n'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nclass Info {\n  constructor() {\n    this.any_blank_count = 0;\n    this.any_blank_ms = 0;\n    this.any_blank_speed_sum = 0;\n    this.mostly_blank_count = 0;\n    this.mostly_blank_ms = 0;\n    this.pixels_blank = 0;\n    this.pixels_sampled = 0;\n    this.pixels_scrolled = 0;\n    this.total_time_spent = 0;\n    this.sample_count = 0;\n  }\n}\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\nvar _sampleRate = DEBUG ? 1 : null;\n/**\r\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\r\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\r\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\r\n *\r\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\r\n * `SceneTracker.getActiveScene` to determine the context of the events.\r\n */\n\nclass FillRateHelper {\n  static addListener(callback) {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      }\n    };\n  }\n  static setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  }\n  static setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  }\n  constructor(getFrameMetrics) {\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    var start = this._samplesStartTime; // const for flow\n\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    var total_time_spent = global.performance.now() - start;\n    var info = _objectSpread(_objectSpread({}, this._info), {}, {\n      total_time_spent\n    });\n    if (DEBUG) {\n      var derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n      for (var key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived,\n        info\n      });\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n  computeBlankness(props, state, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n      return 0;\n    }\n    var dOffset = scrollMetrics.dOffset,\n      offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n\n    var now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n    var blankTop = 0;\n    var first = state.first;\n    var firstFrame = this._getFrameMetrics(first);\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n    var blankBottom = 0;\n    var last = state.last;\n    var lastFrame = this._getFrameMetrics(last);\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      var bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n    var pixels_blank = Math.round(blankTop + blankBottom);\n    var blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n  enabled() {\n    return this._enabled;\n  }\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\nexport default FillRateHelper;","map":{"version":3,"names":["_objectSpread","Info","constructor","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","addListener","callback","console","warn","push","remove","filter","listener","setSampleRate","sampleRate","setMinSampleCount","minSampleCount","getFrameMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_getFrameMetrics","Math","random","_resetData","activate","debug","global","performance","now","deactivateAndFlush","start","info","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","key","round","forEach","computeBlankness","props","state","scrollMetrics","getItemCount","data","dOffset","offset","velocity","visibleLength","abs","scrollSpeed","blankTop","first","firstFrame","last","inLayout","min","max","blankBottom","lastFrame","bottomEdge","length","blankness","enabled"],"sources":["C:/Users/Luc/Documents/ecole/2022_2023/ASI2/Atelier2/atelier2/frontend/node_modules/react-native-web/dist/vendor/react-native/FillRateHelper/index.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n */\r\n'use strict';\r\n\r\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\r\n\r\nclass Info {\r\n  constructor() {\r\n    this.any_blank_count = 0;\r\n    this.any_blank_ms = 0;\r\n    this.any_blank_speed_sum = 0;\r\n    this.mostly_blank_count = 0;\r\n    this.mostly_blank_ms = 0;\r\n    this.pixels_blank = 0;\r\n    this.pixels_sampled = 0;\r\n    this.pixels_scrolled = 0;\r\n    this.total_time_spent = 0;\r\n    this.sample_count = 0;\r\n  }\r\n\r\n}\r\n\r\nvar DEBUG = false;\r\nvar _listeners = [];\r\nvar _minSampleCount = 10;\r\n\r\nvar _sampleRate = DEBUG ? 1 : null;\r\n/**\r\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\r\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\r\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\r\n *\r\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\r\n * `SceneTracker.getActiveScene` to determine the context of the events.\r\n */\r\n\r\n\r\nclass FillRateHelper {\r\n  static addListener(callback) {\r\n    if (_sampleRate === null) {\r\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\r\n    }\r\n\r\n    _listeners.push(callback);\r\n\r\n    return {\r\n      remove: () => {\r\n        _listeners = _listeners.filter(listener => callback !== listener);\r\n      }\r\n    };\r\n  }\r\n\r\n  static setSampleRate(sampleRate) {\r\n    _sampleRate = sampleRate;\r\n  }\r\n\r\n  static setMinSampleCount(minSampleCount) {\r\n    _minSampleCount = minSampleCount;\r\n  }\r\n\r\n  constructor(getFrameMetrics) {\r\n    this._anyBlankStartTime = null;\r\n    this._enabled = false;\r\n    this._info = new Info();\r\n    this._mostlyBlankStartTime = null;\r\n    this._samplesStartTime = null;\r\n    this._getFrameMetrics = getFrameMetrics;\r\n    this._enabled = (_sampleRate || 0) > Math.random();\r\n\r\n    this._resetData();\r\n  }\r\n\r\n  activate() {\r\n    if (this._enabled && this._samplesStartTime == null) {\r\n      DEBUG && console.debug('FillRateHelper: activate');\r\n      this._samplesStartTime = global.performance.now();\r\n    }\r\n  }\r\n\r\n  deactivateAndFlush() {\r\n    if (!this._enabled) {\r\n      return;\r\n    }\r\n\r\n    var start = this._samplesStartTime; // const for flow\r\n\r\n    if (start == null) {\r\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\r\n      return;\r\n    }\r\n\r\n    if (this._info.sample_count < _minSampleCount) {\r\n      // Don't bother with under-sampled events.\r\n      this._resetData();\r\n\r\n      return;\r\n    }\r\n\r\n    var total_time_spent = global.performance.now() - start;\r\n\r\n    var info = _objectSpread(_objectSpread({}, this._info), {}, {\r\n      total_time_spent\r\n    });\r\n\r\n    if (DEBUG) {\r\n      var derived = {\r\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\r\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\r\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\r\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\r\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\r\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\r\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\r\n      };\r\n\r\n      for (var key in derived) {\r\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\r\n      }\r\n\r\n      console.debug('FillRateHelper deactivateAndFlush: ', {\r\n        derived,\r\n        info\r\n      });\r\n    }\r\n\r\n    _listeners.forEach(listener => listener(info));\r\n\r\n    this._resetData();\r\n  }\r\n\r\n  computeBlankness(props, state, scrollMetrics) {\r\n    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\r\n      return 0;\r\n    }\r\n\r\n    var dOffset = scrollMetrics.dOffset,\r\n        offset = scrollMetrics.offset,\r\n        velocity = scrollMetrics.velocity,\r\n        visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\r\n    // we want to capture that.\r\n\r\n    this._info.sample_count++;\r\n    this._info.pixels_sampled += Math.round(visibleLength);\r\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\r\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\r\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\r\n\r\n    var now = global.performance.now();\r\n\r\n    if (this._anyBlankStartTime != null) {\r\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\r\n    }\r\n\r\n    this._anyBlankStartTime = null;\r\n\r\n    if (this._mostlyBlankStartTime != null) {\r\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\r\n    }\r\n\r\n    this._mostlyBlankStartTime = null;\r\n    var blankTop = 0;\r\n    var first = state.first;\r\n\r\n    var firstFrame = this._getFrameMetrics(first);\r\n\r\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\r\n      firstFrame = this._getFrameMetrics(first);\r\n      first++;\r\n    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\r\n    // as blank.\r\n\r\n\r\n    if (firstFrame && first > 0) {\r\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\r\n    }\r\n\r\n    var blankBottom = 0;\r\n    var last = state.last;\r\n\r\n    var lastFrame = this._getFrameMetrics(last);\r\n\r\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\r\n      lastFrame = this._getFrameMetrics(last);\r\n      last--;\r\n    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\r\n    // footer as blank.\r\n\r\n\r\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\r\n      var bottomEdge = lastFrame.offset + lastFrame.length;\r\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\r\n    }\r\n\r\n    var pixels_blank = Math.round(blankTop + blankBottom);\r\n    var blankness = pixels_blank / visibleLength;\r\n\r\n    if (blankness > 0) {\r\n      this._anyBlankStartTime = now;\r\n      this._info.any_blank_speed_sum += scrollSpeed;\r\n      this._info.any_blank_count++;\r\n      this._info.pixels_blank += pixels_blank;\r\n\r\n      if (blankness > 0.5) {\r\n        this._mostlyBlankStartTime = now;\r\n        this._info.mostly_blank_count++;\r\n      }\r\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\r\n      this.deactivateAndFlush();\r\n    }\r\n\r\n    return blankness;\r\n  }\r\n\r\n  enabled() {\r\n    return this._enabled;\r\n  }\r\n\r\n  _resetData() {\r\n    this._anyBlankStartTime = null;\r\n    this._info = new Info();\r\n    this._mostlyBlankStartTime = null;\r\n    this._samplesStartTime = null;\r\n  }\r\n\r\n}\r\n\r\nexport default FillRateHelper;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}