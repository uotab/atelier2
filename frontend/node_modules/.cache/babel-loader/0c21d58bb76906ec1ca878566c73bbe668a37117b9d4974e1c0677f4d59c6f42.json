{"ast":null,"code":"/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n */\n'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport AnimatedNode from './AnimatedNode';\nimport AnimatedTransform from './AnimatedTransform';\nimport AnimatedWithChildren from './AnimatedWithChildren';\nimport NativeAnimatedHelper from '../NativeAnimatedHelper';\nimport StyleSheet from '../../../../exports/StyleSheet';\nvar flattenStyle = StyleSheet.flatten;\nclass AnimatedStyle extends AnimatedWithChildren {\n  constructor(style) {\n    super();\n    style = flattenStyle(style) || {};\n    if (style.transform) {\n      style = _objectSpread(_objectSpread({}, style), {}, {\n        transform: new AnimatedTransform(style.transform)\n      });\n    }\n    this._style = style;\n  } // Recursively get values for nested styles (like iOS's shadowOffset)\n\n  _walkStyleAndGetValues(style) {\n    var updatedStyle = {};\n    for (var key in style) {\n      var value = style[key];\n      if (value instanceof AnimatedNode) {\n        if (!value.__isNative) {\n          // We cannot use value of natively driven nodes this way as the value we have access from\n          // JS may not be up to date.\n          updatedStyle[key] = value.__getValue();\n        }\n      } else if (value && !Array.isArray(value) && typeof value === 'object') {\n        // Support animating nested values (for example: shadowOffset.height)\n        updatedStyle[key] = this._walkStyleAndGetValues(value);\n      } else {\n        updatedStyle[key] = value;\n      }\n    }\n    return updatedStyle;\n  }\n  __getValue() {\n    return this._walkStyleAndGetValues(this._style);\n  } // Recursively get animated values for nested styles (like iOS's shadowOffset)\n\n  _walkStyleAndGetAnimatedValues(style) {\n    var updatedStyle = {};\n    for (var key in style) {\n      var value = style[key];\n      if (value instanceof AnimatedNode) {\n        updatedStyle[key] = value.__getAnimatedValue();\n      } else if (value && !Array.isArray(value) && typeof value === 'object') {\n        // Support animating nested values (for example: shadowOffset.height)\n        updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);\n      }\n    }\n    return updatedStyle;\n  }\n  __getAnimatedValue() {\n    return this._walkStyleAndGetAnimatedValues(this._style);\n  }\n  __attach() {\n    for (var key in this._style) {\n      var value = this._style[key];\n      if (value instanceof AnimatedNode) {\n        value.__addChild(this);\n      }\n    }\n  }\n  __detach() {\n    for (var key in this._style) {\n      var value = this._style[key];\n      if (value instanceof AnimatedNode) {\n        value.__removeChild(this);\n      }\n    }\n    super.__detach();\n  }\n  __makeNative() {\n    for (var key in this._style) {\n      var value = this._style[key];\n      if (value instanceof AnimatedNode) {\n        value.__makeNative();\n      }\n    }\n    super.__makeNative();\n  }\n  __getNativeConfig() {\n    var styleConfig = {};\n    for (var styleKey in this._style) {\n      if (this._style[styleKey] instanceof AnimatedNode) {\n        var style = this._style[styleKey];\n        style.__makeNative();\n        styleConfig[styleKey] = style.__getNativeTag();\n      } // Non-animated styles are set using `setNativeProps`, no need\n      // to pass those as a part of the node config\n    }\n\n    NativeAnimatedHelper.validateStyles(styleConfig);\n    return {\n      type: 'style',\n      style: styleConfig\n    };\n  }\n}\nexport default AnimatedStyle;","map":{"version":3,"names":["_objectSpread","AnimatedNode","AnimatedTransform","AnimatedWithChildren","NativeAnimatedHelper","StyleSheet","flattenStyle","flatten","AnimatedStyle","constructor","style","transform","_style","_walkStyleAndGetValues","updatedStyle","key","value","__isNative","__getValue","Array","isArray","_walkStyleAndGetAnimatedValues","__getAnimatedValue","__attach","__addChild","__detach","__removeChild","__makeNative","__getNativeConfig","styleConfig","styleKey","__getNativeTag","validateStyles","type"],"sources":["C:/Users/Luc/Documents/ecole/2022_2023/ASI2/Atelier2/atelier2/frontend/node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedStyle.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n * @format\r\n */\r\n'use strict';\r\n\r\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\r\nimport AnimatedNode from './AnimatedNode';\r\nimport AnimatedTransform from './AnimatedTransform';\r\nimport AnimatedWithChildren from './AnimatedWithChildren';\r\nimport NativeAnimatedHelper from '../NativeAnimatedHelper';\r\nimport StyleSheet from '../../../../exports/StyleSheet';\r\nvar flattenStyle = StyleSheet.flatten;\r\n\r\nclass AnimatedStyle extends AnimatedWithChildren {\r\n  constructor(style) {\r\n    super();\r\n    style = flattenStyle(style) || {};\r\n\r\n    if (style.transform) {\r\n      style = _objectSpread(_objectSpread({}, style), {}, {\r\n        transform: new AnimatedTransform(style.transform)\r\n      });\r\n    }\r\n\r\n    this._style = style;\r\n  } // Recursively get values for nested styles (like iOS's shadowOffset)\r\n\r\n\r\n  _walkStyleAndGetValues(style) {\r\n    var updatedStyle = {};\r\n\r\n    for (var key in style) {\r\n      var value = style[key];\r\n\r\n      if (value instanceof AnimatedNode) {\r\n        if (!value.__isNative) {\r\n          // We cannot use value of natively driven nodes this way as the value we have access from\r\n          // JS may not be up to date.\r\n          updatedStyle[key] = value.__getValue();\r\n        }\r\n      } else if (value && !Array.isArray(value) && typeof value === 'object') {\r\n        // Support animating nested values (for example: shadowOffset.height)\r\n        updatedStyle[key] = this._walkStyleAndGetValues(value);\r\n      } else {\r\n        updatedStyle[key] = value;\r\n      }\r\n    }\r\n\r\n    return updatedStyle;\r\n  }\r\n\r\n  __getValue() {\r\n    return this._walkStyleAndGetValues(this._style);\r\n  } // Recursively get animated values for nested styles (like iOS's shadowOffset)\r\n\r\n\r\n  _walkStyleAndGetAnimatedValues(style) {\r\n    var updatedStyle = {};\r\n\r\n    for (var key in style) {\r\n      var value = style[key];\r\n\r\n      if (value instanceof AnimatedNode) {\r\n        updatedStyle[key] = value.__getAnimatedValue();\r\n      } else if (value && !Array.isArray(value) && typeof value === 'object') {\r\n        // Support animating nested values (for example: shadowOffset.height)\r\n        updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);\r\n      }\r\n    }\r\n\r\n    return updatedStyle;\r\n  }\r\n\r\n  __getAnimatedValue() {\r\n    return this._walkStyleAndGetAnimatedValues(this._style);\r\n  }\r\n\r\n  __attach() {\r\n    for (var key in this._style) {\r\n      var value = this._style[key];\r\n\r\n      if (value instanceof AnimatedNode) {\r\n        value.__addChild(this);\r\n      }\r\n    }\r\n  }\r\n\r\n  __detach() {\r\n    for (var key in this._style) {\r\n      var value = this._style[key];\r\n\r\n      if (value instanceof AnimatedNode) {\r\n        value.__removeChild(this);\r\n      }\r\n    }\r\n\r\n    super.__detach();\r\n  }\r\n\r\n  __makeNative() {\r\n    for (var key in this._style) {\r\n      var value = this._style[key];\r\n\r\n      if (value instanceof AnimatedNode) {\r\n        value.__makeNative();\r\n      }\r\n    }\r\n\r\n    super.__makeNative();\r\n  }\r\n\r\n  __getNativeConfig() {\r\n    var styleConfig = {};\r\n\r\n    for (var styleKey in this._style) {\r\n      if (this._style[styleKey] instanceof AnimatedNode) {\r\n        var style = this._style[styleKey];\r\n\r\n        style.__makeNative();\r\n\r\n        styleConfig[styleKey] = style.__getNativeTag();\r\n      } // Non-animated styles are set using `setNativeProps`, no need\r\n      // to pass those as a part of the node config\r\n\r\n    }\r\n\r\n    NativeAnimatedHelper.validateStyles(styleConfig);\r\n    return {\r\n      type: 'style',\r\n      style: styleConfig\r\n    };\r\n  }\r\n\r\n}\r\n\r\nexport default AnimatedStyle;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}